(in-package common-lisp)

(export '(defmacro))

(defun extract-envvar (lambda-list)
  ())

(nirvana-builtins:%defmacro
 'defmacro
 #'(lambda (args env)
     (let ((name (car args))
           (lambda-list (cadr args))
           (body (cddr args))
           (i 0)
           (reqvars (vector))
           (optvars (vector))
           restvar
           (keyvars (vector))
           (auxvars (vector))
           envvar
           wholevar
           (mode 'req)
           allow-other-keys)
       (dolist (form lambda-list)
         (cond ((eq form '&whole)
                 (if (and (eq i 0) (null wholevar))
                     (setq mode 'whole)
                     (error "Incorrect &whole placement in macro-lambda-list")))
               ((eq form '&environment)
                 (if (null envvar)
                     (setq mode (cons 'env mode))
                     (error "Repeated &environment")))
               ((eq form '&optional)
                 (if (or (eq mode 'whole)
                         (and (consp mode)
                              (eq (cdr mode) 'whole))
                         (eq mode 'req)
                         (and (consp mode)
                              (eq (cdr mode) 'req)))
                     (setq mode 'opt)
                     (error "Incorrect &optional placement in macro-lambda-list")))
               ((or (eq form '&rest)
                    (eq form '&body))
                 (if (or (eq mode 'whole)
                         (and (consp mode)
                              (eq (cdr mode) 'whole))
                         (eq mode 'req)
                         (and (consp mode)
                              (eq (cdr mode) 'req))
                         (eq mode 'opt)
                         (and (consp mode)
                              (eq (cdr mode) 'opt)))
                     (setq mode 'rest)
                     (error "Incorrect &rest/&body placement in macro-lambda-list")))
               ((eq form '&key)
                 (if (or (eq mode 'whole)
                         (and (consp mode)
                              (eq (cdr mode) 'whole))
                         (eq mode 'req)
                         (and (consp mode)
                              (eq (cdr mode) 'req))
                         (eq mode 'opt)
                         (and (consp mode)
                              (eq (cdr mode) 'opt))
                         (eq mode 'rest)
                         (and (consp mode)
                              (eq (cdr mode) 'rest)))
                     (setq mode 'key)
                     (error "Incorrect &key placement in macro-lambda-list")))
               ((eq form '&allow-other-keys)
                 (if (eq mode 'key)
                     (setq allow-other-keys t)
                     (error "Incorrent &allow-other-keys placement in macro-lambda-list")))
               ((eq form '&aux)
                 (if (or (eq mode 'whole)
                         (and (consp mode)
                              (eq (cdr mode) 'whole))
                         (eq mode 'req)
                         (and (consp mode)
                              (eq (cdr mode) 'req))
                         (eq mode 'opt)
                         (and (consp mode)
                              (eq (cdr mode) 'opt))
                         (eq mode 'rest)
                         (and (consp mode)
                              (eq (cdr mode) 'rest))
                         (eq mode 'key)
                         (and (consp mode)
                              (eq (cdr mode) 'key)))
                     (setq mode 'key)
                     (error "Incorrect &key placement in macro-lambda-list")))
               ;; no lambda list keyword
               ((symbolp form)
                 (cond ((eq mode 'whole)
                         (if (null wholevar)
                             (setq wholevar form)
                             (error "Expected single variable name after &whole")))
                       ((and (consp mode) (eq (car mode) 'env))
                         (if (null envvar)
                             (progn
                              (setq envvar form)
                              (if (or (eq (cdr mode) 'whole)
                                      (eq (cdr mode) 'req))
                                  (setq mode 'req)))
                             (error "Expected single variable name after &environment")))
                       ((eq mode 'req) (vector-push-extend form reqvars))
                       ((eq mode 'opt) (vector-push-extend (list form) optvars))
                       ((eq mode 'rest)
                         (if (null restvar)
                             (setq restvar form)
                             (error "Expected single variable name after &rest")))
                       ((eq mode 'key) (vector-push-extend (list form) keyvars))
                       ((eq mode 'aux) (vector-push-extend (list form) auxvars))))
               ((consp form)
                 (cond ((eq mode 'whole) (error "Expected variable name after &whole"))
                       ((eq mode 'req) (error "Expected variable name as required parameter"))
                       ((eq mode 'opt) (vector-push-extend form optvars))
                       ((eq mode 'rest) (error "Expected variable name after &rest"))
                       ((eq mode 'key) (vector-push-extend form keyvars))
                       ((eq mode 'aux) (vector-push-extend form auxvars))
                       ((and (consp mode) (eq (car mode) 'env)) (error "Expected variable name after &environment")))))
         (setq i (+ i 1)))
       (let ((args '#:args)
             (env '#:env))
         `(nirvana-builtins:%defmacro
           ',name
           #'(lambda (,args ,env)
               (let () ,@body)))))))

(defmacro mac1 (a b)
  `(+ ,a (+ ,b 3)))

; (print "MAC1")
; (print (mac1 4 5))

(defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x)
  `'(,a ,b ,c ,d ,x))